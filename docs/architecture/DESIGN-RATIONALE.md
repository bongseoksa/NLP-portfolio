# 기술 포트폴리오 설계 판단 설명

이 문서는 프로젝트의 주요 아키텍처 결정사항에 대한 설계 판단을 설명합니다.

## 1. ChromaDB를 CI에서만 사용하는 이유

### 핵심 설명

> **"ChromaDB는 임베딩 생성 단계에서만 사용하고, 런타임에서는 파일 기반 검색을 사용합니다. 이는 ChromaDB가 24/7 서버 운영이 필요한 stateful 서비스인데, 우리 시스템은 읽기 전용 Q&A이고 임베딩 생성은 코드 변경 시에만 발생하므로 CI에서 배치 처리하는 것이 비용과 복잡도 측면에서 효율적이기 때문입니다."**

### 상세 판단 근거

**문제점:**
- ChromaDB는 Python 기반 벡터 데이터베이스로 지속적인 서버 프로세스 필요
- 서버 호스팅 비용: $20-50/월 (Docker 컨테이너) 또는 $30-100/월 (Chroma Cloud)
- Serverless 환경과 불일치: Vercel/Lambda는 stateless인데 ChromaDB는 persistent connection 필요
- 읽기 전용 특성: Q&A API는 벡터 검색만 수행하며, 임베딩 생성은 코드 변경 시에만 발생

**해결책:**
- **CI 단계 (GitHub Actions)**: ChromaDB를 임시로 실행하여 임베딩 생성 및 저장
- **Export 단계**: ChromaDB 데이터를 JSON 파일로 export하여 정적 파일 생성
- **런타임**: 파일 기반 검색으로 전환하여 서버 의존성 제거

**결과:**
- ✅ CI 실행 중에만 ChromaDB 사용 (비용 $0)
- ✅ 런타임 서버 비용 $0
- ✅ Serverless 완벽 호환
- ✅ 임베딩 생성은 주기적으로 자동화 (GitHub Actions)

---

## 2. 런타임에서 파일 기반 검색을 사용하는 이유

### 핵심 설명

> **"정적 JSON 파일을 CDN에서 다운로드하여 메모리에 캐싱하고 브루트포스 코사인 유사도 검색을 수행합니다. 벡터 수가 1,000개 이하일 때는 ChromaDB와 비슷한 성능(51-151ms)을 보이면서도 서버 비용을 $0으로 유지할 수 있고, Serverless 환경에서 완벽하게 동작하기 때문입니다."**

### 상세 판단 근거

**문제점:**
- ChromaDB 서버 24/7 운영 필요 → 월 $20-50 비용
- Serverless 환경과 불일치 (stateless vs stateful)
- 읽기 전용 작업에 과도한 인프라

**해결책:**
- **정적 파일 저장**: Gzip 압축된 JSON 파일을 CDN에 저장
- **메모리 캐싱**: Lambda/Vercel 컨테이너 재사용 시 메모리 캐시 활용 (5분 TTL)
- **브루트포스 검색**: O(n) 시간 복잡도이지만 1,000개 이하에서는 충분히 빠름

**성능 비교:**
```
ChromaDB (서버):
- 검색 속도: 10-30ms (HNSW 인덱스)
- 서버 비용: $20-50/월
- Cold Start: 0ms (항상 실행 중)

File-based:
- 검색 속도: 51-151ms (브루트포스)
- 서버 비용: $0/월
- Cold Start: 150-380ms (파일 다운로드)
- Warm Start: 51-151ms (캐시 히트)
```

**결과:**
- ✅ 서버 비용 $0 (정적 파일만)
- ✅ Serverless 완벽 호환
- ✅ CDN 활용으로 빠른 다운로드 (10-30ms)
- ✅ 1,000개 이하 벡터에서는 실용적인 성능

**제한사항:**
- ⚠️ 벡터 수 제한 (메모리 1GB → ~10,000 vectors)
- ⚠️ 실시간 업데이트 불가 (하지만 CI에서 주기적 업데이트로 충분)

---

## 3. 서버리스에서 히스토리를 벡터로 관리하는 방식

### 핵심 설명

> **"Q&A 히스토리를 질문/답변별로 임베딩하여 별도 JSON 파일로 저장하고, 다음 질의 시 코드 벡터와 함께 검색 대상에 포함합니다. Atomic Write 전략과 Hybrid Pruning(시간+중요도)으로 동시성 문제와 무한 증가를 방지하면서도, 이벤트 큐 기반 비동기 처리로 API 응답 속도를 유지합니다."**

### 상세 판단 근거

**문제점:**
- Q&A 히스토리를 벡터로 변환하여 검색 가능하게 만들어야 함
- Serverless 환경에서 동시성 문제 (여러 요청이 동시에 파일 업데이트)
- 히스토리 무한 증가 방지 필요
- API 응답 속도 유지 (히스토리 저장이 응답을 지연시키면 안 됨)

**해결책:**

**1. 분리된 파일 전략:**
- 코드 임베딩과 히스토리 임베딩을 별도 파일로 분리
- 코드는 안정적, 히스토리는 자주 갱신 → 업데이트 영향 최소화

**2. Atomic Write 전략:**
- Write-Then-Move: 임시 파일 작성 → 원자적 이동
- Version-based Update: 낙관적 잠금으로 동시성 문제 회피
- 이벤트 큐 활용: 히스토리 추가를 큐에 넣고 즉시 응답

**3. Hybrid Pruning 전략:**
- 시간 기반: 30일 이상 오래된 데이터 제거
- 개수 기반: 최대 1,000개 히스토리 유지
- 중요도 기반: 성공률, 검색 빈도, 시간 가중치 고려

**4. 비동기 처리:**
- 히스토리 저장은 Promise.all로 병렬 처리
- 실패해도 API 응답은 정상 반환
- 배치 업데이트로 효율성 향상

**결과:**
- ✅ 동시성 안전: Atomic Write로 동시 업데이트 문제 해결
- ✅ 무한 증가 방지: Hybrid Pruning으로 파일 크기 관리
- ✅ 성능 최적화: 비동기 처리로 API 응답 속도 유지
- ✅ 검색 통합: 코드 + 히스토리 동시 검색 지원

---

## 4. 비용을 0원으로 유지한 방법

### 핵심 설명

> **"벡터 데이터베이스 서버를 완전히 제거하고, 정적 JSON 파일을 CDN에 저장하여 Serverless 함수에서 직접 다운로드하는 방식으로 전환했습니다. 임베딩 생성은 GitHub Actions(무료)에서 주기적으로 실행하고, 파일은 Vercel Blob Storage(무료 tier) 또는 S3에 저장하여 서버 운영 비용을 $0으로 유지합니다."**

### 상세 판단 근거

**기존 방식의 비용:**
- ChromaDB 서버 호스팅: $20-50/월
- 또는 Chroma Cloud: $30-100/월
- 또는 Supabase Pro: $25-30/월

**최적화 전략:**

**1. 서버 제거:**
- 벡터 데이터베이스 서버 완전 제거
- 정적 파일로 전환 (embeddings.json.gz)
- Serverless 함수에서 직접 파일 다운로드

**2. 무료 서비스 활용:**
- **GitHub Actions**: CI/CD 무료 (공개 레포지토리)
- **Vercel Blob Storage**: 무료 tier (100GB 저장, 100GB 전송)
- **AWS S3 + CloudFront**: 무료 tier (5GB 저장, 50GB 전송)
- **CDN**: 정적 파일 배포로 빠른 다운로드

**3. 효율적인 파일 관리:**
- Gzip 압축: 파일 크기 70-80% 감소 (7.7MB → 2-3MB)
- 메모리 캐싱: 5분 TTL로 재다운로드 최소화
- HTTP 캐싱: ETag 활용으로 304 Not Modified 응답

**4. 히스토리 관리:**
- 별도 파일로 분리하여 업데이트 영향 최소화
- Pruning으로 파일 크기 제한 (최대 1,000개)
- 이벤트 큐 기반 배치 업데이트

**비용 비교:**

| 항목 | 기존 방식 | 최적화 방식 | 절감액 |
|------|-----------|-------------|--------|
| 벡터 DB 서버 | $20-50/월 | $0/월 | $20-50/월 |
| 파일 저장소 | - | $0/월 (무료 tier) | - |
| CDN 전송 | - | $0/월 (무료 tier) | - |
| **총 비용** | **$20-50/월** | **$0/월** | **$20-50/월** |

**결과:**
- ✅ 서버 비용 $0 (정적 파일만)
- ✅ 저장소 비용 $0 (무료 tier 활용)
- ✅ CDN 비용 $0 (무료 tier 활용)
- ✅ CI/CD 비용 $0 (GitHub Actions 무료)
- ✅ **총 운영 비용: $0/월**

**제한사항:**
- ⚠️ 무료 tier 제한 (파일 크기, 전송량)
- ⚠️ 벡터 수 제한 (메모리 1GB → ~10,000 vectors)
- ⚠️ 실시간 업데이트 불가 (하지만 주기적 업데이트로 충분)

---

## 종합 평가

### 설계 원칙

1. **비용 최적화**: 서버 비용을 $0으로 유지하면서도 실용적인 성능 달성
2. **Serverless 우선**: Vercel/Lambda 환경에 완벽하게 최적화
3. **단순성**: 복잡한 인프라 없이 정적 파일로 해결
4. **확장성**: 벡터 수가 증가하면 ANN 알고리즘으로 전환 가능

### 트레이드오프

**선택한 것:**
- ✅ 서버 비용 $0
- ✅ Serverless 완벽 호환
- ✅ 단순한 아키텍처

**포기한 것:**
- ⚠️ 실시간 업데이트 (주기적 업데이트로 대체)
- ⚠️ 대용량 벡터 세트 성능 (1,000개 이하에서는 충분)
- ⚠️ 복잡한 쿼리 기능 (단순 유사도 검색으로 충분)

### 면접 답변 (30초 버전)

> "벡터 검색 시스템을 Serverless 환경에 최적화하여 운영 비용을 $0으로 유지했습니다. ChromaDB는 임베딩 생성 단계에서만 CI에서 사용하고, 런타임에서는 정적 JSON 파일을 CDN에서 다운로드하여 메모리에서 브루트포스 검색을 수행합니다. 1,000개 이하 벡터에서는 ChromaDB와 비슷한 성능(51-151ms)을 보이면서도 서버 비용을 완전히 제거했고, Q&A 히스토리도 벡터로 변환하여 검색 대상에 포함시켜 점진적으로 학습하는 시스템을 구축했습니다."

